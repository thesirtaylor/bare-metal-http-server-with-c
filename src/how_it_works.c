#define _POSIX_C_SOURCE 200809L
#include "http_server.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// This endpoint explains HOW the server works - the fundamental request/response cycle
// that underlies ALL server-side frameworks (Express, Flask, Django, Rails, etc.)

void handle_how_it_works(const HttpRequest *request, HttpResponse *response) {
    (void)request;  // Unused
    
    // Allocate buffer for complete HTML
    size_t total_size = 60000;  // 60KB
    char *html = malloc(total_size);
    if (!html) {
        response->status_code = 500;
        strcpy(response->content_type, "text/plain");
        response->body = strdup("Memory allocation failed");
        response->body_length = strlen(response->body);
        return;
    }
    
    strcpy(html,
        "<!DOCTYPE html><html><head><title>How Servers Work</title>"
        "<style>"
        "*{box-sizing:border-box;margin:0;padding:0;}"
        "body{font-family:'Courier New',monospace;background:#0a0a0a;color:#00ff00;padding:20px;line-height:1.6;}"
        ".container{max-width:1200px;margin:0 auto;}"
        "h1{color:#00ff00;border-bottom:3px solid #00ff00;padding-bottom:10px;margin-bottom:20px;font-size:32px;}"
        "h2{color:#00aaff;border-bottom:2px solid #00aaff;padding:10px 0;margin:30px 0 15px 0;font-size:24px;}"
        "h3{color:#ffaa00;margin:20px 0 10px 0;font-size:18px;}"
        "h4{color:#ff6600;margin:15px 0 8px 0;font-size:16px;}"
        "p{margin:10px 0;}"
        ".section{background:#1a1a1a;padding:20px;margin:20px 0;border-left:4px solid #00ff00;}"
        ".step{background:#0d0d0d;padding:15px;margin:15px 0;border-left:4px solid #00aaff;}"
        ".code{background:#000;padding:15px;margin:10px 0;overflow-x:auto;border-left:3px solid #ffaa00;}"
        ".code pre{margin:0;color:#00ff00;}"
        ".highlight{color:#ffaa00;font-weight:bold;}"
        ".arrow{color:#00aaff;font-size:20px;font-weight:bold;}"
        ".comparison{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin:20px 0;}"
        ".framework{background:#1a1a1a;padding:15px;border-left:4px solid #00aaff;}"
        ".framework h4{margin-top:0;}"
        ".flow{background:#0d0d0d;padding:15px;margin:15px 0;font-family:monospace;}"
        ".emphasis{color:#ff00ff;font-weight:bold;}"
        "ul,ol{margin:10px 0 10px 30px;}"
        "li{margin:5px 0;}"
        "a{color:#00ff00;text-decoration:none;}"
        "a:hover{color:#00aaff;}"
        ".back{margin:30px 0;padding:15px;background:#1a1a1a;border-left:4px solid #00ff00;}"
        "@media(max-width:768px){.comparison{grid-template-columns:1fr;}}"
        "</style></head><body><div class='container'>"
        
        "<h1>üîß How Servers Work: The Universal Request/Response Cycle</h1>"
        
        "<p style='font-size:18px;color:#00aaff;margin:20px 0;'>"
        "This is the <span class='emphasis'>fundamental mechanism</span> that powers EVERY web server and framework - "
        "from this low-level C implementation to Express.js, Flask, Django, Rails, and Spring Boot."
        "</p>"
        
        "<div class='section'>"
        "<h2>üåç The Universal Pattern</h2>"
        "<p>Every server-side framework (Express, Flask, Django, Rails, ASP.NET) abstracts away the details, "
        "but underneath they ALL do the same thing:</p>"
        "<div class='flow'>"
        "1. <span class='highlight'>Listen</span> on a port (socket)<br>"
        "2. <span class='highlight'>Accept</span> client connections<br>"
        "3. <span class='highlight'>Read</span> HTTP request bytes<br>"
        "4. <span class='highlight'>Parse</span> request into meaningful parts<br>"
        "5. <span class='highlight'>Route</span> to appropriate handler<br>"
        "6. <span class='highlight'>Execute</span> business logic<br>"
        "7. <span class='highlight'>Generate</span> HTTP response<br>"
        "8. <span class='highlight'>Send</span> response bytes back<br>"
        "9. <span class='highlight'>Close</span> connection (or keep-alive)<br>"
        "10. <span class='highlight'>Repeat</span> forever"
        "</div>"
        "<p><span class='emphasis'>This is it.</span> Every web server since the dawn of HTTP does exactly this.</p>"
        "</div>"
        
        "<div class='section'>"
        "<h2>üìä The Complete Request/Response Flow</h2>"
        "<h3>What Happens When You Visit http://localhost:8080/glossary</h3>"
        
        "<div class='step'>"
        "<h4>Step 1: Browser Initiates Connection</h4>"
        "<div class='code'><pre>"
        "Browser (Client):\n"
        "  ‚Üí Resolves localhost to 127.0.0.1\n"
        "  ‚Üí Creates TCP socket\n"
        "  ‚Üí Calls connect(fd, 127.0.0.1:8080)\n"
        "  ‚Üí TCP 3-way handshake: SYN ‚Üí SYN-ACK ‚Üí ACK\n"
        "  ‚Üí Connection established!"
        "</pre></div>"
        "<p><span class='highlight'>C Function:</span> Browser uses <code>connect()</code> - same function available in C</p>"
        "</div>"
        
        "<div class='step'>"
        "<h4>Step 2: Server Accepts Connection</h4>"
        "<div class='code'><pre>"
        "// In src/server.c - main server loop\n"
        "while (server_running) {\n"
        "    // Server is BLOCKED here waiting\n"
        "    client_fd = accept(server_fd, &client_addr, &addr_len);\n"
        "    // Client connected! Now we have a socket to talk to them\n"
        "    \n"
        "    printf(\"[CONNECTION] New connection from %s\\n\", client_ip);\n"
        "}"
        "</pre></div>"
        "<p><span class='highlight'>What happened:</span></p>"
        "<ul>"
        "<li><code>accept()</code> was blocking - server was asleep</li>"
        "<li>Client connection woke it up</li>"
        "<li>OS kernel created new socket for this specific client</li>"
        "<li>Returns <code>client_fd</code> - our communication channel</li>"
        "</ul>"
        "</div>"
        
        "<div class='step'>"
        "<h4>Step 3: Read Raw HTTP Request Bytes</h4>"
        "<div class='code'><pre>"
        "// In src/http_handler.c ‚Üí handle_client_connection()\n"
        "char buffer[BUFFER_SIZE];\n"
        "ssize_t bytes_received = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);\n"
        "buffer[bytes_received] = '\\0';  // Null-terminate the string\n"
        "\n"
        "// Buffer now contains raw HTTP:\n"
        "// \"GET /glossary HTTP/1.1\\r\\n\"\n"
        "// \"Host: localhost:8080\\r\\n\"\n"
        "// \"User-Agent: Mozilla/5.0...\\r\\n\"\n"
        "// \"\\r\\n\"  ‚Üê Empty line signals end of headers"
        "</pre></div>"
        "<p><span class='highlight'>Key Insight:</span> HTTP is just <span class='emphasis'>plain text</span> over TCP! "
        "We're reading raw bytes from the socket.</p>"
        "</div>"
        
        "<div class='step'>"
        "<h4>Step 4: Parse HTTP Request</h4>"
        "<div class='code'><pre>"
        "// In src/http_handler.c ‚Üí parse_http_request()\n"
        "HttpRequest request;\n"
        "\n"
        "// Extract method (GET, POST, etc.)\n"
        "char *method_end = strchr(buffer, ' ');\n"
        "strncpy(request.method_str, buffer, method_end - buffer);\n"
        "\n"
        "// Extract path (/glossary)\n"
        "char *path_start = method_end + 1;\n"
        "char *path_end = strchr(path_start, ' ');\n"
        "strncpy(request.path, path_start, path_end - path_start);\n"
        "\n"
        "// Parse headers line by line\n"
        "char *line = strtok(buffer, \"\\r\\n\");\n"
        "while (line != NULL) {\n"
        "    // Parse \"Header-Name: value\"\n"
        "    char *colon = strchr(line, ':');\n"
        "    // Store header...\n"
        "}"
        "</pre></div>"
        "<p><span class='highlight'>Result:</span> Raw text ‚Üí Structured C struct with fields</p>"
        "</div>"
        
        "<div class='step'>"
        "<h4>Step 5: Route to Handler Function</h4>"
        "<div class='code'><pre>"
        "// In src/routes.c ‚Üí route_request()\n"
        "void route_request(const HttpRequest *request, HttpResponse *response) {\n"
        "    if (request->method == HTTP_GET) {\n"
        "        if (strcmp(request->path, \"/\") == 0) {\n"
        "            handle_root(request, response);  ‚Üê Call handler\n"
        "        } \n"
        "        else if (strcmp(request->path, \"/glossary\") == 0) {\n"
        "            handle_glossary(request, response);  ‚Üê Call this one!\n"
        "        }\n"
        "        else if (strcmp(request->path, \"/info\") == 0) {\n"
        "            handle_info(request, response);\n"
        "        }\n"
        "        else {\n"
        "            handle_not_found(request, response);  ‚Üê 404\n"
        "        }\n"
        "    }\n"
        "    else if (request->method == HTTP_POST) {\n"
        "        // POST handlers...\n"
        "    }\n"
        "}"
        "</pre></div>"
        "<p><span class='highlight'>This is Routing!</span> Match URL path ‚Üí Call appropriate function</p>"
        "<p>Frameworks like Express do: <code>app.get('/glossary', handler)</code> - same concept!</p>"
        "</div>"
        
        "<div class='step'>"
        "<h4>Step 6: Execute Handler (Business Logic)</h4>"
        "<div class='code'><pre>"
        "// In src/glossary.c ‚Üí handle_glossary()\n"
       "void handle_glossary(const HttpRequest *request, HttpResponse *response) {\n"
        "&nbsp;&nbsp;// Allocate memory for HTML content\n"
        "&nbsp;&nbsp;char *html = malloc(50000);\n"
        "&nbsp;&nbsp;if (!html) { perror(&quot;malloc failed&quot;); return; }\n\n"
        "&nbsp;&nbsp;// Build the response content\n"
        "&nbsp;&nbsp;strcpy(html, &quot;&lt;!DOCTYPE html&gt;...&quot;);\n"
        "&nbsp;&nbsp;strcat(html, &quot;&lt;h1&gt;C Glossary&lt;/h1&gt;...&quot;);\n"
        "&nbsp;&nbsp;// ... build complete HTML ...\n\n"
        "&nbsp;&nbsp;// Set response fields\n"
        "&nbsp;&nbsp;response-&gt;status_code = 200;  // OK\n"
        "&nbsp;&nbsp;strcpy(response-&gt;content_type, &quot;text/html&quot;);\n"
        "&nbsp;&nbsp;response-&gt;body = html;\n"
        "&nbsp;&nbsp;response-&gt;body_length = strlen(html);\n"
        "}\n"
        "</pre></div>"
        "<p><span class='highlight'>Business Logic:</span> This is where YOU decide what to do:</p>"
        "<ul>"
        "<li>Query database</li>"
        "<li>Process form data</li>"
        "<li>Generate HTML</li>"
        "<li>Return JSON</li>"
        "<li>Read files</li>"
        "<li>Call APIs</li>"
        "</ul>"
        "</div>"
        
        "<div class='step'>"
        "<h4>Step 7: Build HTTP Response</h4>"
        "<div class='code'><pre>"
        "// In src/http_handler.c ‚Üí send_http_response()\n"
        "\n"
        "// Format HTTP response (plain text protocol)\n"
        "char response_header[BUFFER_SIZE];\n"
        "snprintf(response_header, sizeof(response_header),\n"
        "    \"HTTP/1.1 %d %s\\r\\n\"           ‚Üê Status line\n"
        "    \"Content-Type: %s\\r\\n\"          ‚Üê Headers\n"
        "    \"Content-Length: %zu\\r\\n\"\n"
        "    \"Connection: close\\r\\n\"\n"
        "    \"\\r\\n\",                          ‚Üê Empty line = end of headers\n"
        "    response->status_code,\n"
        "    get_status_text(response->status_code),\n"
        "    response->content_type,\n"
        "    response->body_length\n"
        ");\n"
        "\n"
        "// Result looks like:\n"
        "// \"HTTP/1.1 200 OK\\r\\n\"\n"
        "// \"Content-Type: text/html\\r\\n\"\n"
        "// \"Content-Length: 25678\\r\\n\"\n"
        "// \"Connection: close\\r\\n\"\n"
        "// \"\\r\\n\"\n"
        "// <!DOCTYPE html>..."
        "</pre></div>"
        "<p><span class='highlight'>HTTP Response = Text format following RFC 2616 protocol</span></p>"
        "</div>"
        
        "<div class='step'>"
        "<h4>Step 8: Send Response Bytes Back</h4>"
        "<div class='code'><pre>"
        "// Send headers\n"
        "ssize_t sent = send(client_fd, response_header, strlen(response_header), 0);\n"
        "\n"
        "// Send body (HTML content)\n"
        "sent = send(client_fd, response->body, response->body_length, 0);\n"
        "\n"
        "// Data is now traveling through:\n"
        "// ‚Üí Socket buffer\n"
        "// ‚Üí OS kernel network stack  \n"
        "// ‚Üí Network interface card\n"
        "// ‚Üí TCP/IP packets\n"
        "// ‚Üí Router\n"
        "// ‚Üí Client's network interface\n"
        "// ‚Üí Client's OS\n"
        "// ‚Üí Browser process\n"
        "// ‚Üí Browser renders HTML!"
        "</pre></div>"
        "<p><span class='highlight'>Physical reality:</span> Your HTML is being transmitted as electrical signals!</p>"
        "</div>"
        
        "<div class='step'>"
        "<h4>Step 9: Clean Up & Close</h4>"
        "<div class='code'><pre>"
        "// Free allocated memory\n"
        "if (response->body) {\n"
        "    free(response->body);\n"
        "}\n"
        "\n"
        "// Close the client connection\n"
        "close(client_fd);\n"
        "\n"
        "// TCP graceful shutdown:\n"
        "// ‚Üí FIN packet sent\n"
        "// ‚Üí Client ACKs\n"
        "// ‚Üí Connection terminated"
        "</pre></div>"
        "</div>"
        
        "<div class='step'>"
        "<h4>Step 10: Loop Back to Accept</h4>"
        "<div class='code'><pre>"
        "while (server_running) {\n"
        "    client_fd = accept(server_fd, ...);  ‚Üê Back to waiting\n"
        "    handle_client_connection(client_fd);\n"
        "    close(client_fd);\n"
        "}\n"
        "// Server never stops - always ready for next request!"
        "</pre></div>"
        "</div>"
        "</div>");
    
    strcat(html,
        "<div class='section'>"
        "<h2>üéØ How Frameworks Abstract This</h2>"
        "<p>Every framework does the EXACT same steps, but hides the complexity:</p>"
        
        "<div class='comparison'>"
        "<div class='framework'>"
        "<h4>Our C Server (Explicit)</h4>"
        "<div class='code'><pre>"
        "// Step 1-3: Listen & Accept\n"
        "int fd = socket(AF_INET, SOCK_STREAM, 0);\n"
        "bind(fd, &addr, sizeof(addr));\n"
        "listen(fd, 10);\n"
        "client = accept(fd, ...);\n"
        "\n"
        "// Step 4: Read & Parse\n"
        "recv(client, buffer, size, 0);\n"
        "parse_http_request(buffer, &request);\n"
        "\n"
        "// Step 5: Route\n"
        "if (strcmp(path, \"/api\") == 0) {\n"
        "    handle_api(&request, &response);\n"
        "}\n"
        "\n"
        "// Step 6: Business logic\n"
        "response.body = generate_html();\n"
        "\n"
        "// Step 7-8: Build & Send\n"
        "char *http = format_response(&response);\n"
        "send(client, http, len, 0);\n"
        "\n"
        "// Step 9: Clean up\n"
        "close(client);"
        "</pre></div>"
        "</div>"
        
        "<div class='framework'>"
        "<h4>Express.js (Abstracted)</h4>"
        "<div class='code'><pre>"
        "// Framework handles Steps 1-4, 7-9!\n"
        "\n"
        "const express = require('express');\n"
        "const app = express();\n"
        "\n"
        "// You only write Step 5-6:\n"
        "\n"
        "app.get('/api', (req, res) => {\n"
        "    // req = parsed request (Step 4 done)\n"
        "    // Business logic (Step 6)\n"
        "    const html = generateHTML();\n"
        "    \n"
        "    // res.send() does Steps 7-8\n"
        "    res.send(html);\n"
        "});\n"
        "\n"
        "// listen() does Steps 1-3, 9-10\n"
        "app.listen(8080);"
        "</pre></div>"
        "</div>"
        "</div>"
        
        "<div class='comparison'>"
        "<div class='framework'>"
        "<h4>Flask (Python)</h4>"
        "<div class='code'><pre>"
        "from flask import Flask\n"
        "app = Flask(__name__)\n"
        "\n"
        "@app.route('/api')  # Routing\n"
        "def handle_api():   # Handler\n"
        "    html = generate_html()\n"
        "    return html  # Flask formats & sends\n"
        "\n"
        "app.run(port=8080)  # Listen forever"
        "</pre></div>"
        "</div>"
        
        "<div class='framework'>"
        "<h4>Django (Python)</h4>"
        "<div class='code'><pre>"
        "# urls.py\n"
        "urlpatterns = [\n"
        "    path('api/', views.handle_api),\n"
        "]\n"
        "\n"
        "# views.py\n"
        "def handle_api(request):\n"
        "    html = generate_html()\n"
        "    return HttpResponse(html)"
        "</pre></div>"
        "</div>"
        "</div>"
        
        "<div class='comparison'>"
        "<div class='framework'>"
        "<h4>Rails (Ruby)</h4>"
        "<div class='code'><pre>"
        "# routes.rb\n"
        "get '/api', to: 'pages#api'\n"
        "\n"
        "# pages_controller.rb\n"
        "class PagesController\n"
        "  def api\n"
        "    html = generate_html\n"
        "    render html: html\n"
        "  end\n"
        "end"
        "</pre></div>"
        "</div>"
        
        "<div class='framework'>"
        "<h4>Spring Boot (Java)</h4>"
        "<div class='code'><pre>"
        "@RestController\n"
        "public class ApiController {\n"
        "    \n"
        "    @GetMapping(\"/api\")\n"
        "    public String handleApi() {\n"
        "        String html = generateHTML();\n"
        "        return html;\n"
        "    }\n"
        "}"
        "</pre></div>"
        "</div>"
        "</div>"
        
        "<p style='margin-top:20px;'><span class='emphasis'>The pattern is identical across ALL frameworks:</span></p>"
        "<ol>"
        "<li>Define route (URL path)</li>"
        "<li>Associate with handler function</li>"
        "<li>Handler receives parsed request</li>"
        "<li>Handler returns response</li>"
        "<li>Framework handles socket I/O</li>"
        "</ol>"
        "</div>"
        
        "<div class='section'>"
        "<h2>üîç Deep Dive: What You DON'T See in Frameworks</h2>"
        
        "<h3>1. Socket Management</h3>"
        "<div class='code'><pre>"
        "// C: You create and manage sockets\n"
        "int server_fd = socket(AF_INET, SOCK_STREAM, 0);\n"
        "setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n"
        "\n"
        "// Framework: Hidden - done for you\n"
        "app.listen(8080);  // Creates socket internally"
        "</pre></div>"
        
        "<h3>2. Byte-Level I/O</h3>"
        "<div class='code'><pre>"
        "// C: You read raw bytes\n"
        "char buffer[4096];\n"
        "ssize_t n = recv(client_fd, buffer, sizeof(buffer), 0);\n"
        "if (n <= 0) { /* handle error */ }\n"
        "\n"
        "// Framework: Hidden\n"
        "app.get('/api', (req, res) => {\n"
        "    // req is already parsed!\n"
        "});"
        "</pre></div>"
        
        "<h3>3. HTTP Protocol Formatting</h3>"
        "<div class='code'><pre>"
        "// C: You build HTTP response manually\n"
        "snprintf(header, size, \n"
        "    \"HTTP/1.1 200 OK\\r\\n\"\n"
        "    \"Content-Type: text/html\\r\\n\"\n"
        "    \"Content-Length: %zu\\r\\n\\r\\n\",\n"
        "    body_length);\n"
        "\n"
        "// Framework: Hidden\n"
        "res.status(200).send(html);  // Builds HTTP for you"
        "</pre></div>"
        
        "<h3>4. Memory Management</h3>"
        "<div class='code'><pre>"
        "// C: You allocate and free\n"
        "char *body = malloc(10000);\n"
        "strcpy(body, \"<html>...\");\n"
        "send(fd, body, strlen(body), 0);\n"
        "free(body);  // Must free!\n"
        "\n"
        "// Framework: Garbage collected\n"
        "const html = '<html>...';\n"
        "res.send(html);  // Memory managed automatically"
        "</pre></div>"
        
        "<h3>5. Error Handling</h3>"
        "<div class='code'><pre>"
        "// C: Check every system call\n"
        "if (socket_fd < 0) { perror(\"socket\"); return -1; }\n"
        "if (bind(fd, ...) < 0) { perror(\"bind\"); return -1; }\n"
        "if (listen(fd, 10) < 0) { perror(\"listen\"); return -1; }\n"
        "\n"
        "// Framework: Try-catch / error middleware\n"
        "app.use((err, req, res, next) => {\n"
        "    res.status(500).send('Error');\n"
        "});"
        "</pre></div>"
        
        "<h3>6. Concurrency</h3>"
        "<div class='code'><pre>"
        "// C: You manage threads/processes\n"
        "pthread_t thread;\n"
        "pthread_create(&thread, NULL, handle_client, &client_fd);\n"
        "pthread_detach(thread);\n"
        "\n"
        "// Framework: Built-in\n"
        "app.listen(8080);  // Handles concurrent requests automatically"
        "</pre></div>"
        "</div>");
    
    strcat(html,
        "<div class='section'>"
        "<h2>üí° Key Insights</h2>"
        
        "<h3>1. HTTP is Just Text Over TCP</h3>"
        "<p>There's no magic - it's literally strings following a format:</p>"
        "<div class='code'><pre>"
        "\"GET /glossary HTTP/1.1\\r\\n\"\n"
        "\"Host: localhost:8080\\r\\n\"\n"
        "\"\\r\\n\""
        "</pre></div>"
        "<p>Browser sends this, server reads it, parses it, responds with more text.</p>"
        
        "<h3>2. Sockets are File Descriptors</h3>"
        "<p>In Unix, <span class='emphasis'>everything is a file</span>:</p>"
        "<ul>"
        "<li><code>fd 0</code> = stdin</li>"
        "<li><code>fd 1</code> = stdout</li>"
        "<li><code>fd 2</code> = stderr</li>"
        "<li><code>fd 3+</code> = files, sockets, pipes</li>"
        "</ul>"
        "<p>You <code>read()</code> and <code>write()</code> to sockets just like files!</p>"
        
        "<h3>3. The Request/Response is Synchronous (Sequential)</h3>"
        "<p>One request at a time (in our basic server):</p>"
        "<div class='flow'>"
        "Accept ‚Üí Read ‚Üí Parse ‚Üí Route ‚Üí Execute ‚Üí Send ‚Üí Close ‚Üí Repeat"
        "</div>"
        "<p>To handle multiple clients: threads, processes, or event loops (epoll)</p>"
        
        "<h3>4. Frameworks Trade Control for Convenience</h3>"
        "<table style='width:100%;margin:20px 0;'>"
        "<tr style='background:#1a1a1a;'>"
        "<th style='padding:10px;text-align:left;border:1px solid #00ff00;'>Aspect</th>"
        "<th style='padding:10px;text-align:left;border:1px solid #00ff00;'>Low-Level C</th>"
        "<th style='padding:10px;text-align:left;border:1px solid #00ff00;'>Framework</th>"
        "</tr>"
        "<tr style='background:#0d0d0d;'>"
        "<td style='padding:10px;border:1px solid #333;'>Control</td>"
        "<td style='padding:10px;border:1px solid #333;'>Complete</td>"
        "<td style='padding:10px;border:1px solid #333;'>Limited</td>"
        "</tr>"
        "<tr style='background:#0d0d0d;'>"
        "<td style='padding:10px;border:1px solid #333;'>Code Length</td>"
        "<td style='padding:10px;border:1px solid #333;'>~500+ lines</td>"
        "<td style='padding:10px;border:1px solid #333;'>~50 lines</td>"
        "</tr>"
        "<tr style='background:#0d0d0d;'>"
        "<td style='padding:10px;border:1px solid #333;'>Speed</td>"
        "<td style='padding:10px;border:1px solid #333;'>Fastest</td>"
        "<td style='padding:10px;border:1px solid #333;'>Fast enough</td>"
        "</tr>"
        "<tr style='background:#0d0d0d;'>"
        "<td style='padding:10px;border:1px solid #333;'>Learning</td>"
        "<td style='padding:10px;border:1px solid #333;'>Hard</td>"
        "<td style='padding:10px;border:1px solid #333;'>Easy</td>"
        "</tr>"
        "<tr style='background:#0d0d0d;'>"
        "<td style='padding:10px;border:1px solid #333;'>Debugging</td>"
        "<td style='padding:10px;border:1px solid #333;'>Hard</td>"
        "<td style='padding:10px;border:1px solid #333;'>Easy</td>"
        "</tr>"
        "<tr style='background:#0d0d0d;'>"
        "<td style='padding:10px;border:1px solid #333;'>Understanding</td>"
        "<td style='padding:10px;border:1px solid #333;'>Deep</td>"
        "<td style='padding:10px;border:1px solid #333;'>Surface</td>"
        "</tr>"
        "</table>"
        
        "<h3>5. All Servers Follow This Pattern</h3>"
        "<p>From nginx to Apache to Node.js to your framework:</p>"
        "<ul>"
        "<li>‚úÖ Socket creation</li>"
        "<li>‚úÖ Binding to port</li>"
        "<li>‚úÖ Accepting connections</li>"
        "<li>‚úÖ Reading bytes</li>"
        "<li>‚úÖ Parsing protocol</li>"
        "<li>‚úÖ Routing requests</li>"
        "<li>‚úÖ Executing handlers</li>"
        "<li>‚úÖ Formatting responses</li>"
        "<li>‚úÖ Sending bytes</li>"
        "<li>‚úÖ Managing resources</li>"
        "</ul>"
        "<p><span class='emphasis'>This is universal.</span> It's not magic, it's just sockets and text.</p>"
        "</div>"
        
        "<div class='section'>"
        "<h2>üéì Why This Matters</h2>"
        
        "<h3>1. Debugging Production Issues</h3>"
        "<p>When your Express app hangs, knowing it's because <code>accept()</code> is blocking helps you understand "
        "event loops and async I/O.</p>"
        
        "<h3>2. Performance Optimization</h3>"
        "<p>Understanding that each request = <code>recv() ‚Üí parse ‚Üí execute ‚Üí send()</code> helps you optimize "
        "hot paths and reduce latency.</p>"
        
        "<h3>3. Choosing Technologies</h3>"
        "<p>Knowing the underlying model helps you choose:</p>"
        "<ul>"
        "<li>Thread-per-request (traditional): Simple but doesn't scale to 10k connections</li>"
        "<li>Event-loop (Node.js): Single-threaded but handles many connections</li>"
        "<li>Multi-process (Gunicorn): Multiple workers</li>"
        "</ul>"
        
        "<h3>4. Building Your Own Tools</h3>"
        "<p>Want to build a WebSocket server? HTTP/2? GraphQL? You need to understand:</p>"
        "<ul>"
        "<li>How to read from sockets</li>"
        "<li>How to parse protocols</li>"
        "<li>How to manage connections</li>"
        "</ul>"
        
        "<h3>5. Interview Success</h3>"
        "<p>\"Explain how a web server works\" is a common question. Now you know the real answer.</p>"
        "</div>"
        
        "<div class='section'>"
        "<h2>üìö Our Server's Architecture</h2>"
        "<div class='code'><pre>"
        "src/\n"
        "‚îú‚îÄ‚îÄ main.c              ‚Üí Entry point\n"
        "‚îú‚îÄ‚îÄ server.c            ‚Üí Steps 1-3, 9-10 (socket management)\n"
        "‚îú‚îÄ‚îÄ http_handler.c      ‚Üí Steps 4, 7-8 (HTTP protocol)\n"
        "‚îú‚îÄ‚îÄ routes.c            ‚Üí Step 5 (routing logic)\n"
        "‚îú‚îÄ‚îÄ glossary.c          ‚Üí Step 6 (business logic - handler)\n"
        "‚îî‚îÄ‚îÄ utils.c             ‚Üí Helper functions\n"
        "\n"
        "The 10 Steps Mapped to Files:\n"
        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        "1-3:   server.c         ‚Üí socket(), bind(), listen(), accept()\n"
        "4:     http_handler.c   ‚Üí recv(), parse_http_request()\n"
        "5:     routes.c         ‚Üí route_request() (if/else routing)\n"
        "6:     glossary.c       ‚Üí handle_glossary() (YOUR code)\n"
        "7-8:   http_handler.c   ‚Üí format_response(), send()\n"
        "9-10:  server.c         ‚Üí close(), loop back"
        "</pre></div>"
        "</div>"
        
        "<div class='section'>"
        "<h2>üöÄ Next Level: How to Scale</h2>"
        "<p>Our server handles one client at a time (sequential). To scale:</p>"
        
        "<h3>Option 1: Multi-Threading (We implemented this!)</h3>"
        "<div class='code'><pre>"
        "accept() ‚Üí spawn thread ‚Üí thread handles request ‚Üí thread exits\n"
        "Works for: 100-1000 concurrent connections"
        "</pre></div>"
        
        "<h3>Option 2: Multi-Processing (fork)</h3>"
        "<div class='code'><pre>"
        "accept() ‚Üí fork() ‚Üí child handles request ‚Üí child exits\n"
        "Used by: Apache (prefork mode)\n"
        "Works for: 100-1000 concurrent connections"
        "</pre></div>"
        
        "<h3>Option 3: Event Loop (epoll/kqueue)</h3>"
        "<div class='code'><pre>"
        "epoll_wait([fd1, fd2, fd3...]) ‚Üí handle ready fds ‚Üí repeat\n"
        "Used by: nginx, Node.js, Redis\n"
        "Works for: 10,000+ concurrent connections (C10K problem)"
        "</pre></div>"
        
        "<h3>Option 4: Async/Await (Abstracted Event Loop)</h3>"
        "<div class='code'><pre>"
        "async function handler(req, res) {\n"
        "    const data = await db.query();  // Non-blocking!\n"
        "    res.send(data);\n"
        "}\n"
        "Used by: Node.js, Python asyncio\n"
        "Hides complexity of event loop"
        "</pre></div>"
        "</div>"
        
        "<div class='section'>"
        "<h2>üéØ Summary: The Universal Truth</h2>"
        "<p style='font-size:18px;'><span class='emphasis'>Every web server, regardless of language or framework, "
        "does the exact same thing at its core:</span></p>"
        "<div class='flow' style='font-size:16px;'>"
        "Socket ‚Üí Accept ‚Üí Read ‚Üí Parse ‚Üí Route ‚Üí Execute ‚Üí Format ‚Üí Send ‚Üí Close ‚Üí Repeat"
        "</div>"
        "<p>Understanding this gives you:</p>"
        "<ul>"
        "<li>‚úÖ Deep understanding of web architecture</li>"
        "<li>‚úÖ Ability to debug any server-side issue</li>"
        "<li>‚úÖ Knowledge to build your own servers/frameworks</li>"
        "<li>‚úÖ Context for performance optimization</li>"
        "<li>‚úÖ Foundation for distributed systems</li>"
        "</ul>"
        "<p style='margin-top:20px;font-size:18px;color:#00aaff;'>"
        "You now understand what happens <span class='emphasis'>behind the scenes</span> of every "
        "<code>app.get()</code>, every <code>@app.route()</code>, every <code>def view()</code>, "
        "every REST API, every microservice, and every web application on the internet."
        "</p>"
        "</div>"
        
        "<div class='back'>"
        "<a href='/'>‚Üê Back to home</a> | "
        "<a href='/info'>Network concepts</a> | "
        "<a href='/glossary'>C reference</a>"
        "</div>"
        
        "</div></body></html>");
    
    response->status_code = 200;
    strcpy(response->content_type, "text/html; charset=utf-8");
    response->body = html;
    response->body_length = strlen(html);
}